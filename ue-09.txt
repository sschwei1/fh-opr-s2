=== ./ue-09/src/main/java/at/fhhgb/mc/snake/game/Snake.java ===
package at.fhhgb.mc.snake.game;

import at.fhhgb.mc.snake.game.entity.SnakePartEntity;
import at.fhhgb.mc.snake.game.entity.manager.EntityManager;
import at.fhhgb.mc.snake.game.options.GameOptions;
import at.fhhgb.mc.snake.game.struct.Point2D;
import at.fhhgb.mc.snake.log.GLog;

import java.util.LinkedList;
import java.util.List;

public class Snake {
    public enum Direction {
        UP, DOWN, LEFT, RIGHT;

        public Direction inverse() {
            return switch (this) {
                case UP -> DOWN;
                case DOWN -> UP;
                case LEFT -> RIGHT;
                case RIGHT -> LEFT;
            };
        }

        public boolean isInverse(Direction direction) {
            return this == direction.inverse();
        }

        public boolean isInverseOrEqual(Direction direction) {
            return this == direction || this.isInverse(direction);
        }
    }

    private LinkedList<SnakePartEntity> parts;
    private final GameOptions options;
    private final EntityManager entityManager;

    public Snake(GameOptions options, EntityManager entityManager) {
        this.options = options;
        this.entityManager = entityManager;

        GLog.info("Init Snake: " + options.getInitialSnakeLength());
        this.initSnake(options.getInitialSnakeLength());
    }

    public int getSize() {
        return this.parts.size();
    }

    private void initSnake(int size) {
        this.parts = new LinkedList<>();
        this.increaseSizeBy(size);
    }

    public void increaseSize() {
        if(!this.parts.isEmpty()) {
            SnakePartEntity newPart = this.parts.getLast().clone();
            this.parts.add(newPart);
            this.entityManager.register(newPart);
            return;
        }

        Point2D startingPos = this.options.getStartingPosition().clone();
        startingPos.setMaxX(options.getGameWidth());
        startingPos.setMaxY(options.getGameHeight());

        SnakePartEntity head = new SnakePartEntity(startingPos,true);

        this.parts.addFirst(head);
        this.entityManager.register(head);
    }

    public void increaseSizeBy(int amount) {
        for(int i = 0; i < amount; i++) {
            this.increaseSize();
        }
    }

    public void move(Direction direction) {
        if(this.parts.isEmpty()) {
            throw new IllegalStateException("Unable to move empty snake.");
        }

        SnakePartEntity head = this.parts.getFirst();

        if(this.parts.size() > 1) {
            SnakePartEntity partToMove = this.parts.getLast();
            this.entityManager.move(partToMove, head.getPosition().clone());
            this.parts.removeLast();
            this.parts.add(1, partToMove);
        }

        this.entityManager.move(head, direction);
    }

    public List<SnakePartEntity> getParts() {
        return this.parts;
    }
}

=== ./ue-09/src/main/java/at/fhhgb/mc/snake/game/entity/WallEntity.java ===
package at.fhhgb.mc.snake.game.entity;

import at.fhhgb.mc.snake.game.event.entity.EntityDeathEvent;
import at.fhhgb.mc.snake.game.event.entity.EntityEvent;
import at.fhhgb.mc.snake.game.renderer.GameCell;
import at.fhhgb.mc.snake.game.struct.Point2D;
import javafx.scene.paint.Color;

import java.util.List;

public class WallEntity extends AbstractEntity {
    public WallEntity(Point2D position) {
        super(position, Color.DARKGRAY);
    }

    @Override
    public int getRenderingPriority() {
        return 20;
    }

    @Override
    public GameCell.State getType() {
        return GameCell.State.WALL;
    }

    @Override
    public List<EntityEvent> onConsume() {
        return List.of(
            new EntityDeathEvent(this)
        );
    }
}

=== ./ue-09/src/main/java/at/fhhgb/mc/snake/game/entity/Consumable.java ===
package at.fhhgb.mc.snake.game.entity;

import at.fhhgb.mc.snake.game.event.entity.EntityEvent;

import java.util.List;

public interface Consumable {
    List<EntityEvent> onConsume();
}

=== ./ue-09/src/main/java/at/fhhgb/mc/snake/game/entity/SnakePartEntity.java ===
package at.fhhgb.mc.snake.game.entity;

import at.fhhgb.mc.snake.game.event.entity.EntityDeathEvent;
import at.fhhgb.mc.snake.game.event.entity.EntityEvent;
import at.fhhgb.mc.snake.game.renderer.GameCell;
import at.fhhgb.mc.snake.game.struct.Point2D;
import javafx.scene.paint.Color;

import java.util.List;

public class SnakePartEntity extends AbstractEntity implements Cloneable {
    private boolean isHead;

    public SnakePartEntity(Point2D position) {
        this(position, false);
    }

    public SnakePartEntity(Point2D position, boolean isHead) {
        super(position, Color.GREEN);
        this.isHead = isHead;
    }

    @Override
    public Color getColor() {
        return this.isHead ? Color.LIGHTGREEN : Color.GREEN;
    }

    @Override
    public int getRenderingPriority() {
        return this.isHead ? 30 : 10;
    }

    @Override
    public GameCell.State getType() {
        return this.isHead ?
            GameCell.State.SNAKE_HEAD :
            GameCell.State.SNAKE;
    }

    @Override
    public List<EntityEvent> onConsume() {
        if (this.isHead) {
            return List.of();
        }

        return List.of(
            new EntityDeathEvent(this)
        );
    }

    @Override
    public SnakePartEntity clone() {
        try {
            SnakePartEntity clone = (SnakePartEntity) super.clone();
            clone.position = this.position.clone();
            clone.isHead = false;
            return clone;
        } catch (CloneNotSupportedException e) {
            throw new AssertionError();
        }
    }
}

=== ./ue-09/src/main/java/at/fhhgb/mc/snake/game/entity/manager/EntityManager.java ===
package at.fhhgb.mc.snake.game.entity.manager;

import at.fhhgb.mc.snake.game.Snake;
import at.fhhgb.mc.snake.game.entity.AbstractEntity;
import at.fhhgb.mc.snake.game.event.entity.EntityEvent;
import at.fhhgb.mc.snake.game.options.GameOptions;
import at.fhhgb.mc.snake.game.renderer.GameCell;
import at.fhhgb.mc.snake.game.struct.Point2D;
import at.fhhgb.mc.snake.log.GLog;

import java.util.*;
import java.util.stream.IntStream;

public class EntityManager {
    private static class DummyEntity extends AbstractEntity {
        private final int hash;

        public DummyEntity(Point2D position, int hash) {
            super(position, null);
            this.hash = hash;
        }

        @Override
        public int getRenderingPriority() {
            return this.hash;
        }

        @Override
        public GameCell.State getType() {
            return null;
        }

        @Override
        public List<EntityEvent> onConsume() {
            return List.of();
        }

        @Override
        public int hashCode() {
            return this.hash;
        }
    }

    private final TreeSet<AbstractEntity> entities;
    private final HashSet<Point2D> emptyPositions;

    private final HashSet<Point2D> positionsToClear;
    private final HashSet<AbstractEntity> dirtyEntities;


    public EntityManager(GameOptions options) {
        Comparator<AbstractEntity> comparator = Comparator
            .comparing(AbstractEntity::getPosition)
            .thenComparing(AbstractEntity::getRenderingPriority)
            .thenComparing(AbstractEntity::hashCode);

        this.entities = new TreeSet<>(comparator);
        this.emptyPositions = IntStream.range(0, options.getFieldSize())
                                  .mapToObj(number -> Point2D.fromInt(
                                      number,
                                      options.getGameWidth(),
                                      options.getGameHeight()
                                  ))
                                    .collect(HashSet::new, HashSet::add, HashSet::addAll);

        this.positionsToClear = new HashSet<>();
        this.dirtyEntities = new HashSet<>();
    }

    public boolean register(AbstractEntity entity) {
        GLog.info("Register entity: " + entity);
        this.dirtyEntities.add(entity);
        this.emptyPositions.remove(entity.getPosition());
        return this.entities.add(entity);
    }

    public boolean unregister(AbstractEntity entity) {
        boolean wasRemoved = this.entities.remove(entity);

        this.positionsToClear.add(entity.getPosition().clone());
        Collection<AbstractEntity> subSet = this.getAllWithPosition(entity.getPosition());
        if(subSet.isEmpty()) {
            this.emptyPositions.add(entity.getPosition().clone());
        }

        return wasRemoved;
    }

    public boolean has(AbstractEntity entity) {
        return this.entities.contains(entity);
    }

    public void move(AbstractEntity entity, Point2D newPosition) {
        if(!this.has(entity)) {
            entity.setPosition(newPosition);
            return;
        }

        this.unregister(entity);
        entity.setPosition(newPosition);
        this.register(entity);
    }

    public void move(AbstractEntity entity, Snake.Direction direction) {
        if(!this.has(entity)) {
            entity.getPosition().move(direction);
            return;
        }

        this.unregister(entity);
        entity.getPosition().move(direction);
        this.register(entity);
    }

    public Collection<AbstractEntity> getAll() {
        return this.entities;
    }

    public List<AbstractEntity> getAllWithPosition(Point2D position) {
        DummyEntity from = new DummyEntity(position, Integer.MIN_VALUE);
        DummyEntity to = new DummyEntity(position, Integer.MAX_VALUE);

        return new ArrayList<>(this.entities.subSet(from, true, to, true));
    }

    public HashSet<Point2D> getEmptyPositions() {
        return this.emptyPositions;
    }

    public HashSet<Point2D> getPositionsToClear() {
        return this.positionsToClear;
    }

    public HashSet<AbstractEntity> getDirtyEntities() {
        return this.dirtyEntities;
    }

    public void resetDirtyCollections() {
        this.dirtyEntities.clear();
        this.positionsToClear.clear();
    }

    public void clear() {
        this.entities.clear();
        this.emptyPositions.clear();
        this.positionsToClear.clear();
        this.dirtyEntities.clear();
    }
}

=== ./ue-09/src/main/java/at/fhhgb/mc/snake/game/entity/FoodEntity.java ===
package at.fhhgb.mc.snake.game.entity;

import at.fhhgb.mc.snake.game.event.entity.EntityEvent;
import at.fhhgb.mc.snake.game.event.entity.EntityGrowthEvent;
import at.fhhgb.mc.snake.game.event.entity.EntityPointsEvent;
import at.fhhgb.mc.snake.game.event.entity.EntitySpawnFoodEvent;
import at.fhhgb.mc.snake.game.options.FoodConfig;
import at.fhhgb.mc.snake.game.renderer.GameCell;
import at.fhhgb.mc.snake.game.struct.Point2D;
import at.fhhgb.mc.snake.log.GLog;
import javafx.scene.paint.Color;

import java.util.List;

public class FoodEntity extends AbstractEntity {
    private final int sizeIncrease;
    private final int pointsIncrease;
    private final int spawnNewAmount;

    public FoodEntity(Point2D position) {
        this(position, 1, 100, 1, Color.RED);
    }

    public FoodEntity(Point2D position, FoodConfig.FoodValueConfig foodValueConfig) {
        this(
            position,
            foodValueConfig.lengthIncrease(),
            foodValueConfig.pointIncrease(),
            foodValueConfig.spawnNewAmount(),
            foodValueConfig.color()
        );
    }

    public FoodEntity(Point2D position, int sizeIncrease, int pointsIncrease, int spawnNewAmount, Color color) {
        super(position, color);
        this.sizeIncrease = sizeIncrease;
        this.pointsIncrease = pointsIncrease;
        this.spawnNewAmount = spawnNewAmount;

        GLog.info("Init Food");
    }

    @Override
    public boolean shouldRemoveOnConsume() {
        return true;
    }

    @Override
    public int getRenderingPriority() {
        return 20;
    }

    @Override
    public GameCell.State getType() {
        return GameCell.State.FOOD;
    }

    @Override
    public List<EntityEvent> onConsume() {
        return List.of(
            new EntityGrowthEvent(this, this.sizeIncrease),
            new EntityPointsEvent(this, this.pointsIncrease),
            new EntitySpawnFoodEvent(this, this.spawnNewAmount)
        );
    }
}

=== ./ue-09/src/main/java/at/fhhgb/mc/snake/game/entity/AbstractEntity.java ===
package at.fhhgb.mc.snake.game.entity;

import at.fhhgb.mc.snake.game.event.entity.EntityEvent;
import at.fhhgb.mc.snake.game.renderer.GameCell;
import at.fhhgb.mc.snake.game.struct.Point2D;
import javafx.scene.paint.Color;

import java.util.List;

public abstract class AbstractEntity implements Consumable {
    protected Point2D position;
    protected Color color;

    public AbstractEntity(Point2D position, Color color) {
        this.position = position;
        this.color = color;
    }

    public Point2D getPosition() {
        return position;
    }

    public AbstractEntity setPosition(Point2D position) {
        this.position = position;
        return this;
    }

    public Color getColor() {
        return color;
    }

    public AbstractEntity setColor(Color color) {
        this.color = color;
        return this;
    }

    public boolean shouldRemoveOnConsume() {
        return false;
    }

    public abstract int getRenderingPriority();
    public abstract GameCell.State getType();
    public abstract List<EntityEvent> onConsume();

    @Override
    public String toString() {
        String className = this.getClass().getSimpleName();
        return className + " [position=" + position + ", type=" + getType() + ", hash=" + this.hashCode() + "]";
    }
}

=== ./ue-09/src/main/java/at/fhhgb/mc/snake/game/options/GameFieldConfig.java ===
package at.fhhgb.mc.snake.game.options;

import at.fhhgb.mc.snake.game.struct.Point2D;

public record GameFieldConfig(int width, int height, Point2D startingPos, boolean wallEnabled) {

}

=== ./ue-09/src/main/java/at/fhhgb/mc/snake/game/options/FoodConfig.java ===
package at.fhhgb.mc.snake.game.options;

import javafx.scene.paint.Color;

import java.util.List;

public record FoodConfig(int initiallySpawnedFood, List<FoodValueConfig> availableFood) {
    public record FoodValueConfig(int pointIncrease, int lengthIncrease, int spawnNewAmount, Color color) {
        public FoodValueConfig {
            if (pointIncrease < 0 || lengthIncrease < 0) {
                throw new IllegalArgumentException("Point and length increase must be non-negative.");
            }
        }
    }

    public FoodConfig {
        if (availableFood == null || availableFood.isEmpty()) {
            throw new IllegalArgumentException("Configured food cannot be null or empty.");
        }
    }
}

=== ./ue-09/src/main/java/at/fhhgb/mc/snake/game/options/GameOptions.java ===
package at.fhhgb.mc.snake.game.options;

import at.fhhgb.mc.snake.game.struct.Point2D;
import javafx.scene.paint.Color;

import java.util.ArrayList;
import java.util.List;

public class GameOptions {
    private int tickSpeed;
    private int initialSnakeLength;

    private GameFieldConfig gameFieldConfig;
    private FoodConfig foodConfig;

    private GameOptions() { }

    public int getTickSpeed() {
        return tickSpeed;
    }

    public GameOptions setTickSpeed(int moveSpeed) {
        this.tickSpeed = moveSpeed;
        return this;
    }

    public int getGameWidth() {
        int offset = this.gameFieldConfig.wallEnabled() ? 2 : 0;
        return offset + this.gameFieldConfig.width();
    }

    public int getGameWidthWithoutOffset() {
        return this.gameFieldConfig.width();
    }

    public int getGameHeight() {
        int offset = this.gameFieldConfig.wallEnabled() ? 2 : 0;
        return offset + this.gameFieldConfig.height();
    }

    public int getGameHeightWithoutOffset() {
        return this.gameFieldConfig.height();
    }

    public GameOptions setGameSizeConfig(GameFieldConfig gameFieldConfig) {
        this.gameFieldConfig = gameFieldConfig;
        return this;
    }

    public GameOptions setFoodConfig(FoodConfig foodConfig) {
        this.foodConfig = foodConfig;
        return this;
    }

    public int getFieldSize() {
        return this.getGameWidth() * this.getGameHeight();
    }

    public int getFieldSizeWithoutOffset() {
        return this.getGameWidthWithoutOffset() * this.getGameHeightWithoutOffset();
    }

    public int getInitialSnakeLength() {
        return initialSnakeLength;
    }

    public GameOptions setInitialSnakeLength(int initialSnakeLength) {
        this.initialSnakeLength = initialSnakeLength;
        return this;
    }

    public Point2D getStartingPosition() {
        return this.gameFieldConfig.startingPos();
    }

    public boolean isWallEnabled() {
        return this.gameFieldConfig.wallEnabled();
    }

    public List<FoodConfig.FoodValueConfig> getAvailableFoods() {
        return this.foodConfig.availableFood();
    }

    public static GameOptions getEasyMode() {
        GameOptions easyOptions = new GameOptions();
        easyOptions.tickSpeed = 100;
        easyOptions.initialSnakeLength = 5;
        easyOptions.gameFieldConfig = new GameFieldConfig(20, 20, new Point2D(1,1), false);
        easyOptions.foodConfig = new FoodConfig(1, new ArrayList<>() {{
            add(
                new FoodConfig.FoodValueConfig(
                    20,
                    1,
                    1,
                    Color.RED
                )
            );
        }});

        return easyOptions;
    }

    public static GameOptions getMediumMode() {
        GameOptions mediumOptions = new GameOptions();
        mediumOptions.tickSpeed = 100;
        mediumOptions.initialSnakeLength = 5;
        mediumOptions.gameFieldConfig = new GameFieldConfig(20, 20, new Point2D(1,1), false);
        mediumOptions.foodConfig = new FoodConfig(1, new ArrayList<>() {{
            add(new FoodConfig.FoodValueConfig(100, 3, 1, Color.RED));
        }});

        return mediumOptions;
    }

    public static GameOptions getHardMode() {
        GameOptions hardOptions = new GameOptions();
        hardOptions.tickSpeed = 50;
        hardOptions.initialSnakeLength = 5;
        hardOptions.gameFieldConfig = new GameFieldConfig(20, 20, new Point2D(1,1), false);
        hardOptions.foodConfig = new FoodConfig(1, new ArrayList<>() {{
            add(new FoodConfig.FoodValueConfig(200, 5, 1, Color.RED));
        }});

        return hardOptions;
    }

    public static GameOptions getDefaultCustomOptions() {
        GameOptions defaultOptions = new GameOptions();
        defaultOptions.tickSpeed = 50;
        defaultOptions.initialSnakeLength = 5;
        defaultOptions.gameFieldConfig = new GameFieldConfig(20, 20, new Point2D(1,1), false);
        defaultOptions.foodConfig = new FoodConfig(1, new ArrayList<>() {{
            add(new FoodConfig.FoodValueConfig(100, 5, 1, Color.YELLOW));
            add(new FoodConfig.FoodValueConfig(200, 8, 1, Color.ORANGE));
            add(new FoodConfig.FoodValueConfig(300, 10, 1, Color.RED));
        }});

        return defaultOptions;
    }

    private static GameOptions readGameOptionsFromFile() {
        // TODO: Implement file reading logic
        return getDefaultCustomOptions();
    }

    private static void writeGameOptionsToFile(GameOptions options) {
        // TODO: Implement file writing logic
    }
}

=== ./ue-09/src/main/java/at/fhhgb/mc/snake/game/SnakeGame.java ===
package at.fhhgb.mc.snake.game;

import at.fhhgb.mc.snake.game.entity.AbstractEntity;
import at.fhhgb.mc.snake.game.entity.FoodEntity;
import at.fhhgb.mc.snake.game.entity.WallEntity;
import at.fhhgb.mc.snake.game.entity.manager.EntityManager;
import at.fhhgb.mc.snake.game.event.entity.EntityEvent;
import at.fhhgb.mc.snake.game.event.entity.EntityGrowthEvent;
import at.fhhgb.mc.snake.game.event.entity.EntityPointsEvent;
import at.fhhgb.mc.snake.game.event.entity.EntitySpawnFoodEvent;
import at.fhhgb.mc.snake.game.event.state.StateEvent;
import at.fhhgb.mc.snake.game.event.state.game.OnGameOverEvent;
import at.fhhgb.mc.snake.game.event.state.game.OnGameStartEvent;
import at.fhhgb.mc.snake.game.event.state.game.OnGamePauseEvent;
import at.fhhgb.mc.snake.game.event.state.game.OnGameResumeEvent;
import at.fhhgb.mc.snake.game.event.state.snake.OnSnakePointsChangeEvent;
import at.fhhgb.mc.snake.game.event.state.snake.OnSnakeSizeChangeEvent;
import at.fhhgb.mc.snake.game.options.FoodConfig;
import at.fhhgb.mc.snake.game.options.GameOptions;
import at.fhhgb.mc.snake.game.renderer.DefaultRenderer;
import at.fhhgb.mc.snake.game.renderer.GameCell;
import at.fhhgb.mc.snake.game.renderer.AbstractGameRenderer;
import at.fhhgb.mc.snake.game.struct.Point2D;
import at.fhhgb.mc.snake.log.GLog;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.event.EventTarget;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.*;
import javafx.util.Duration;

import java.util.*;
import java.util.function.Consumer;

public class SnakeGame {
    private final GameOptions options;

    private final Pane container;
    private AbstractGameRenderer renderer;
    private Timeline timer;

    private EventHandler<KeyEvent> keyEventHandler;
    private EventTarget eventTarget;

    private Consumer<OnSnakePointsChangeEvent> onPointsUpdate;
    private Consumer<OnGameOverEvent> onGameOver;
    private Consumer<OnSnakeSizeChangeEvent> onSnakeGrowth;
    private Consumer<OnGameStartEvent> onGameStart;
    private Consumer<OnGamePauseEvent> onGamePause;
    private Consumer<OnGameResumeEvent> onGameResume;

    private Random random;
    private boolean isRunning;
    private boolean isPaused;
    private boolean inverseDirection;

    private List<Snake.Direction> queuedDirections;
    private Snake.Direction currentDirection;
    private Snake snake;
    private int score;

    private EntityManager entityManager;

    public SnakeGame(Pane container, GameOptions options) {
        this.options = options;
        this.container = container;
        this.initGame();
    }

    private void initGame() {
        this.initData();
        this.initWalls();
        this.initContainer();
        this.initTimer();
        this.initKeyListener();

        this.handleSpawnFoodEvent(new EntitySpawnFoodEvent(null, 1));
        Objects.requireNonNull(this.renderer).update();
    }

    private void initData() {
        this.random = new Random();
        this.isRunning = false;
        this.isPaused = false;
        this.inverseDirection = false;

        this.entityManager = new EntityManager(this.options);
        this.renderer = new DefaultRenderer(this.options, this.entityManager);

        this.queuedDirections = new LinkedList<>();
        this.currentDirection = Snake.Direction.RIGHT;
        this.snake = new Snake(this.options, this.entityManager);
        this.score = 0;

        this.onPointsUpdate = null;
        this.onGameOver = null;
        this.onSnakeGrowth = null;
        this.onGameStart = null;
        this.onGamePause = null;
        this.onGameResume = null;
    }

    private void initWalls() {
        if(!this.options.isWallEnabled()) {
            return;
        }

        for(int x = 0; x < this.options.getGameWidth(); x++) {
            this.registerWall(x, 0);
            this.registerWall(x, this.options.getGameHeight() - 1);
        }

        for(int y = 0; y < this.options.getGameHeight(); y++) {
            this.registerWall(0, y);
            this.registerWall(this.options.getGameWidth() - 1, y);
        }
    }

    private void registerWall(int x, int y) {
        Point2D wallPos = new Point2D(x, y, this.options.getGameWidth(), this.options.getGameHeight());
        WallEntity wall = new WallEntity(wallPos);
        this.entityManager.register(wall);
    }

    private void initContainer() {
        GridPane grid = new GridPane();

        for (int i = 0; i < this.options.getGameWidth(); i++) {
            ColumnConstraints column = new ColumnConstraints();
            column.setHgrow(Priority.ALWAYS);
            grid.getColumnConstraints().add(column);
        }

        for (int i = 0; i < this.options.getGameHeight(); i++) {
            RowConstraints row = new RowConstraints();
            row.setVgrow(Priority.ALWAYS);
            grid.getRowConstraints().add(row);
        }

        GameCell[][] gameView = this.renderer.getGameGrid();

        for(int row = 0; row < this.options.getGameHeight(); row++) {
            for(int col = 0; col < this.options.getGameWidth(); col++) {
                grid.add(gameView[col][row], col, row);
            }
        }

        this.container.getChildren().clear();
        this.container.getChildren().add(grid);
    }

    private void initTimer() {
        this.timer = new Timeline(
            new KeyFrame(Duration.millis(this.options.getTickSpeed()), this::gameLoop)
        );

        this.timer.setCycleCount(Timeline.INDEFINITE);
    }

    private void initKeyListener() {
        GLog.info("Init KeyListener");
        this.eventTarget = Optional
            .<EventTarget>ofNullable(this.container.getScene())
            .orElse(this.container);

        if(this.eventTarget == this.container) {
            this.container.setFocusTraversable(true);
        }

        /*
         * this::keyEventHandler returns a new function ref object each time
         * so we need to store it, to correctly clean it up
         */
        this.keyEventHandler = this::handleKeyEvent;
        this.eventTarget.addEventHandler(KeyEvent.KEY_PRESSED, this.keyEventHandler);
    }

    public void start() {
        this.isRunning = true;
        this.emitInitialData();
        this.emitStateEvent(this.onGameStart, new OnGameStartEvent());

        this.timer.play();
    }

    private void emitInitialData() {
        this.emitStateEvent(
            this.onPointsUpdate,
            new OnSnakePointsChangeEvent(this.score, 0)
        );

        this.emitStateEvent(
            this.onSnakeGrowth,
            new OnSnakeSizeChangeEvent(this.snake.getSize(), 0)
        );
    }

    private void end() {
        this.end(false);
    }

    private void end(boolean isWin) {
        this.isRunning = false;
        this.timer.stop();

        this.emitStateEvent(
            this.onGameOver,
            new OnGameOverEvent(this.score, this.snake, isWin)
        );
    }

    public void cleanup() {
        this.isRunning = false;
        this.timer.stop();
        this.eventTarget.removeEventHandler(KeyEvent.KEY_PRESSED, this.keyEventHandler);
        this.container.getChildren().clear();
        this.snake.getParts().clear();
        this.entityManager.clear();
    }

    private void gameLoop(ActionEvent event) {
        var time = System.currentTimeMillis();
        this.updateEntities();
        var afterUpdateTime = System.currentTimeMillis();
        System.out.println("Update Entities Duration: " + (afterUpdateTime - time));
        this.updateData();
        var afterDataUpdateTime = System.currentTimeMillis();
        System.out.println("Update Data Duration: " + (afterDataUpdateTime - afterUpdateTime));
        renderer.update();
        var afterRenderTime = System.currentTimeMillis();
        System.out.println("Render Duration: " + (afterRenderTime - afterDataUpdateTime));
        System.out.println("Game loop took: " + (System.currentTimeMillis() - time) + "ms");
        System.out.println("Total entities: " + this.entityManager.getAll().size());
    }

    private void updateEntities() {
        GLog.info("Start updating Entities");
        if(!this.queuedDirections.isEmpty()) {
            this.currentDirection = this.queuedDirections.removeFirst();
        }

        this.snake.move(this.currentDirection);
        GLog.info("End updating Entities");
    }

    private void updateData() {
        GLog.info("Start updating Data");
        Point2D headPos = this.snake.getParts().getFirst().getPosition();
        List<AbstractEntity> consumedEntities = this.entityManager.getAllWithPosition(headPos);

        GLog.info("Snake Head: " + headPos);

        for(AbstractEntity entity : consumedEntities) {
            GLog.info("Consume: " + entity.getType());
            this.consumeEvents(entity.onConsume());

            if(entity.shouldRemoveOnConsume()) {
                GLog.info("Unregister Entity: " + entity);
                this.entityManager.unregister(entity);
            }
        }

        GLog.info("End updating Data");
    }

    private void consumeEvents(List<EntityEvent> events) {
        for(EntityEvent event : events) {
            switch(event.getEventType()) {
                case POINTS:     handlePointsEvent(event);      break;
                case GROWTH:     handleGrowthEvent(event);      break;
                case DEATH:      handleDeathEvent();            break;
                case SPAWN_FOOD: handleSpawnFoodEvent(event);   break;
            }
        }
    }

    private void handlePointsEvent(EntityEvent event) {
        if(!(event instanceof EntityPointsEvent pointsEvent)) return;

        this.score += pointsEvent.getPointsChange();

        this.emitStateEvent(
            this.onPointsUpdate,
            new OnSnakePointsChangeEvent(this.score, pointsEvent.getPointsChange())
        );
    }

    private void handleGrowthEvent(EntityEvent event) {
        if(!(event instanceof EntityGrowthEvent growthEvent)) return;

        this.snake.increaseSizeBy(growthEvent.getGrowthSize());

        this.emitStateEvent(
            this.onSnakeGrowth,
            new OnSnakeSizeChangeEvent(this.snake.getSize(), growthEvent.getGrowthSize())
        );
    }

    private void handleDeathEvent() {
        if(!this.isRunning) return;
        GLog.info("Game Over");
        this.end();
    }

    private void handleSpawnFoodEvent(EntityEvent event) {
        if(!(event instanceof EntitySpawnFoodEvent spawnFoodEvent)) return;

        int fieldSize = this.options.getFieldSize();
        if(this.snake.getSize() == fieldSize) {
            this.end(true);
            return;
        }

        HashSet<Point2D> availablePositions = this.entityManager.getEmptyPositions();

        for(int i = 0; i < spawnFoodEvent.getAmount() && !availablePositions.isEmpty(); i++) {
            int randomPosIndex = this.random.nextInt(availablePositions.size());
            Point2D foodPosition = availablePositions.stream()
                .skip(randomPosIndex)
                .findFirst()
                .orElseThrow(() -> new IllegalStateException("No available positions for food."));

            int randomFoodIndex = this.random.nextInt(this.options.getAvailableFoods().size());
            FoodConfig.FoodValueConfig foodValueConfig = this.options.getAvailableFoods().get(randomFoodIndex);

            this.entityManager.register(new FoodEntity(
                foodPosition,
                foodValueConfig
            ));
        }
    }

    private void handleKeyEvent(KeyEvent event) {
        if(!this.isRunning) return;

        this.handleUpdateDirection(event);
        this.handlePause(event);
        event.consume();
    }

    private void handleUpdateDirection(KeyEvent event) {
        Snake.Direction newDirection = switch (event.getCode()) {
            case W, UP      -> Snake.Direction.UP;
            case S, DOWN    -> Snake.Direction.DOWN;
            case A, LEFT    -> Snake.Direction.LEFT;
            case D, RIGHT   -> Snake.Direction.RIGHT;
            default -> null;
        };

        if(newDirection == null) {
            return;
        }

        if(this.inverseDirection) {
            newDirection = newDirection.inverse();
        }

        this.updateQueuedDirection(newDirection);
    }

    private void updateQueuedDirection(Snake.Direction newDirection) {
        if(this.queuedDirections.size() >= 2) {
            this.queuedDirections.clear();
        }

        Snake.Direction compareDirection = this.queuedDirections.isEmpty()
            ? this.currentDirection
            : this.queuedDirections.getLast();

        if(newDirection.isInverseOrEqual(compareDirection)) {
            return;
        }

        this.queuedDirections.add(newDirection);
    }

    private void handlePause(KeyEvent event) {
        if(event.getCode() != KeyCode.P) {
            return;
        }

        GLog.info("Pause triggered");

        this.isPaused = !this.isPaused;

        if(this.isPaused) {
            this.timer.stop();
            this.emitStateEvent(this.onGamePause, new OnGamePauseEvent());
            return;
        }

        this.timer.play();
        this.emitStateEvent(this.onGameResume, new OnGameResumeEvent());
    }

    private <T extends StateEvent> void emitStateEvent(Consumer<T> eventHandler, T event) {
        if(eventHandler != null) {
            eventHandler.accept(event);
        }
    }

    public SnakeGame setOnPointsUpdate(Consumer<OnSnakePointsChangeEvent> onPointsUpdate) {
        this.onPointsUpdate = onPointsUpdate;
        return this;
    }

    public SnakeGame setOnGameOver(Consumer<OnGameOverEvent> onGameOver) {
        this.onGameOver = onGameOver;
        return this;
    }

    public SnakeGame setOnSnakeGrowth(Consumer<OnSnakeSizeChangeEvent> onSnakeGrowth) {
        this.onSnakeGrowth = onSnakeGrowth;
        return this;
    }

    public SnakeGame setOnGameStart(Consumer<OnGameStartEvent> onGameStart) {
        this.onGameStart = onGameStart;
        return this;
    }

    public SnakeGame setOnPause(Consumer<OnGamePauseEvent> onGamePause) {
        this.onGamePause = onGamePause;
        return this;
    }

    public SnakeGame setOnResume(Consumer<OnGameResumeEvent> onGameResume) {
        this.onGameResume = onGameResume;
        return this;
    }
}

=== ./ue-09/src/main/java/at/fhhgb/mc/snake/game/renderer/GameCell.java ===
package at.fhhgb.mc.snake.game.renderer;

import at.fhhgb.mc.snake.game.entity.AbstractEntity;
import javafx.scene.layout.*;
import javafx.scene.paint.Color;

import java.util.Map;
import java.util.WeakHashMap;

public class GameCell extends Pane {
    public enum State {
        EMPTY, FOOD, SNAKE_HEAD, SNAKE, WALL
    }

    private static final Map<Color, String> colorStyleCache = new WeakHashMap<>();

    private int currentPriority;

    public GameCell() {
        this(State.EMPTY, -1);
    }

    public GameCell(State state, int currentPriority) {
        this.setState(state);
        this.currentPriority = currentPriority;

        this.setBorder(new Border(
            new BorderStroke(
                Color.DARKGRAY,
                BorderStrokeStyle.SOLID,
                CornerRadii.EMPTY,
                new BorderWidths(1)
            )
        ));
    }

    public GameCell setState(AbstractEntity entity) {
        if(this.currentPriority >= entity.getRenderingPriority()) {
            return this;
        }

        this.currentPriority = entity.getRenderingPriority();

        return (entity.getType() == State.EMPTY || entity.getColor() == null)
            ? this.setState(entity.getType())
            : this.setState(entity.getColor());
    }

    public GameCell setState(State state) {
        switch (state) {
            case EMPTY      -> this.setStyle(null);
            case FOOD       -> this.setStyle("-fx-background-color: red");
            case SNAKE_HEAD -> this.setStyle("-fx-background-color: lightgreen");
            case SNAKE      -> this.setStyle("-fx-background-color: green");
            case WALL       -> this.setStyle("-fx-background-color: gray");
        }

        return this;
    }

    public GameCell setState(Color color) {
        if(color == null) {
            this.setStyle(null);
            return this;
        }

        String fxColor = colorStyleCache.computeIfAbsent(color, c -> String.format(
            "-fx-background-color: rgba(%d, %d, %d, %.2f)",
            (int) (c.getRed() * 255),
            (int) (c.getGreen() * 255),
            (int) (c.getBlue() * 255),
            c.getOpacity()
        ));
        this.setStyle(fxColor);

        return this;
    }

    public void clear() {
        this.currentPriority = -1;
        this.setState(State.EMPTY);
    }
}

=== ./ue-09/src/main/java/at/fhhgb/mc/snake/game/renderer/DefaultRenderer.java ===
package at.fhhgb.mc.snake.game.renderer;

import at.fhhgb.mc.snake.game.entity.AbstractEntity;
import at.fhhgb.mc.snake.game.entity.manager.EntityManager;
import at.fhhgb.mc.snake.game.options.GameOptions;
import at.fhhgb.mc.snake.game.struct.Point2D;
import at.fhhgb.mc.snake.log.GLog;

public class DefaultRenderer extends AbstractGameRenderer {
    private GameCell[][] gameGrid;

    private final Point2D offset;

    public DefaultRenderer(GameOptions options, EntityManager entityManager) {
        super(options, entityManager);

        this.offset = this.options.isWallEnabled() ?
            new Point2D(1, 1) :
            new Point2D(0, 0);

        this.initGameGrid();
    }

    private void initGameGrid() {
        int gameWidth = this.options.getGameWidth() + 2 * this.offset.getX();
        int gameHeight = this.options.getGameHeight() + 2 * this.offset.getY();

        this.gameGrid = new GameCell[gameWidth][gameHeight];

        for(int i = 0; i < gameWidth; i++) {
            this.gameGrid[i] = new GameCell[gameHeight];
            for(int j = 0; j < gameHeight; j++) {
                this.gameGrid[i][j] = new GameCell();
            }
        }
    }

    @Override
    public GameCell[][] getGameGrid() {
        return this.gameGrid;
    }

    @Override
    public GameCell getCellAt(int x, int y) {
        return this.gameGrid[x][y];
    }

    @Override
    public void update() {
        GLog.info("Start Rendering");

        for(Point2D pos : this.entityManager.getPositionsToClear()) {
            this.getCellAt(pos).clear();
        }

        for(AbstractEntity entity : this.entityManager.getDirtyEntities()) {
            this.getCellAt(entity.getPosition()).setState(entity);
        }

        this.entityManager.resetDirtyCollections();

        GLog.info("Stop Rendering");
    }
}

=== ./ue-09/src/main/java/at/fhhgb/mc/snake/game/renderer/AbstractGameRenderer.java ===
package at.fhhgb.mc.snake.game.renderer;

import at.fhhgb.mc.snake.game.entity.manager.EntityManager;
import at.fhhgb.mc.snake.game.options.GameOptions;
import at.fhhgb.mc.snake.game.struct.Point2D;

public abstract class AbstractGameRenderer {
    protected final GameOptions options;
    protected final EntityManager entityManager;

    public AbstractGameRenderer(GameOptions options, EntityManager entityManager) {
        this.options = options;
        this.entityManager = entityManager;
    }

    public GameCell getCellAt(Point2D point) {
        return getCellAt(point.getX(), point.getY());
    }

    public abstract GameCell[][] getGameGrid();
    public abstract GameCell getCellAt(int x, int y);
    public abstract void update();
}

=== ./ue-09/src/main/java/at/fhhgb/mc/snake/game/event/entity/EntityPointsEvent.java ===
package at.fhhgb.mc.snake.game.event.entity;

import at.fhhgb.mc.snake.game.entity.AbstractEntity;

public class EntityPointsEvent extends EntityEvent {
    private final int pointsChange;

    public EntityPointsEvent(AbstractEntity source, int pointsChange) {
        super(source);
        this.pointsChange = pointsChange;
    }

    public int getPointsChange() {
        return this.pointsChange;
    }

    @Override
    public EntityEventType getEventType() {
        return EntityEventType.POINTS;
    }
}

=== ./ue-09/src/main/java/at/fhhgb/mc/snake/game/event/entity/EntityGrowthEvent.java ===
package at.fhhgb.mc.snake.game.event.entity;

import at.fhhgb.mc.snake.game.entity.AbstractEntity;

public class EntityGrowthEvent extends EntityEvent {
    private final int growthSize;

    public EntityGrowthEvent(AbstractEntity source, int growthSize) {
        super(source);
        this.growthSize = growthSize;
    }

    public int getGrowthSize() {
        return this.growthSize;
    }

    @Override
    public EntityEventType getEventType() {
        return EntityEventType.GROWTH;
    }
}

=== ./ue-09/src/main/java/at/fhhgb/mc/snake/game/event/entity/EntitySpawnFoodEvent.java ===
package at.fhhgb.mc.snake.game.event.entity;

import at.fhhgb.mc.snake.game.entity.AbstractEntity;

public class EntitySpawnFoodEvent extends EntityEvent {
    private final int amount;

    public EntitySpawnFoodEvent(AbstractEntity source) {
        this(source, 1);
    }

    public EntitySpawnFoodEvent(AbstractEntity source, int amount) {
        super(source);
        this.amount = amount;
    }

    public int getAmount() {
        return this.amount;
    }

    @Override
    public EntityEventType getEventType() {
        return EntityEventType.SPAWN_FOOD;
    }
}

=== ./ue-09/src/main/java/at/fhhgb/mc/snake/game/event/entity/EntityEvent.java ===
package at.fhhgb.mc.snake.game.event.entity;

import at.fhhgb.mc.snake.game.entity.AbstractEntity;

public abstract class EntityEvent {
    public enum EntityEventType {
        GROWTH, DEATH, POINTS, SPAWN_FOOD
    }

    private final AbstractEntity source;

    public EntityEvent(AbstractEntity source) {
        this.source = source;
    }

    public AbstractEntity getSource() {
        return this.source;
    }

    public abstract EntityEventType getEventType();
}

=== ./ue-09/src/main/java/at/fhhgb/mc/snake/game/event/entity/EntityDeathEvent.java ===
package at.fhhgb.mc.snake.game.event.entity;

import at.fhhgb.mc.snake.game.entity.AbstractEntity;

public class EntityDeathEvent extends EntityEvent {
    public EntityDeathEvent(AbstractEntity source) {
        super(source);
    }

    @Override
    public EntityEventType getEventType() {
        return EntityEventType.DEATH;
    }
}

=== ./ue-09/src/main/java/at/fhhgb/mc/snake/game/event/state/game/OnGameOverEvent.java ===
package at.fhhgb.mc.snake.game.event.state.game;

import at.fhhgb.mc.snake.game.Snake;
import at.fhhgb.mc.snake.game.event.state.StateEvent;

public class OnGameOverEvent extends StateEvent {
    private final int totalPoints;
    private final Snake snake;
    private final boolean isWin;

    public OnGameOverEvent(int totalPoints, Snake snake) {
        this(totalPoints, snake, false);
    }

    public OnGameOverEvent(int totalPoints, Snake snake, boolean isWin) {
        this.totalPoints = totalPoints;
        this.snake = snake;
        this.isWin = isWin;
    }

    public int getTotalPoints() {
        return this.totalPoints;
    }

    public Snake getSnake() {
        return this.snake;
    }

    public boolean isWin() {
        return this.isWin;
    }

    @Override
    public StateEventType getType() {
        return StateEventType.GAME_OVER;
    }
}

=== ./ue-09/src/main/java/at/fhhgb/mc/snake/game/event/state/game/OnGameStartEvent.java ===
package at.fhhgb.mc.snake.game.event.state.game;

import at.fhhgb.mc.snake.game.event.state.StateEvent;

public class OnGameStartEvent extends StateEvent {
    @Override
    public StateEventType getType() {
        return StateEventType.GAME_START;
    }
}

=== ./ue-09/src/main/java/at/fhhgb/mc/snake/game/event/state/game/OnGameResumeEvent.java ===
package at.fhhgb.mc.snake.game.event.state.game;

import at.fhhgb.mc.snake.game.event.state.StateEvent;

public class OnGameResumeEvent extends StateEvent {
    @Override
    public StateEventType getType() {
        return StateEventType.GAME_RESUME;
    }
}

=== ./ue-09/src/main/java/at/fhhgb/mc/snake/game/event/state/game/OnGamePauseEvent.java ===
package at.fhhgb.mc.snake.game.event.state.game;

import at.fhhgb.mc.snake.game.event.state.StateEvent;

public class OnGamePauseEvent extends StateEvent {
    @Override
    public StateEventType getType() {
        return StateEventType.GAME_PAUSE;
    }
}

=== ./ue-09/src/main/java/at/fhhgb/mc/snake/game/event/state/snake/OnSnakePointsChangeEvent.java ===
package at.fhhgb.mc.snake.game.event.state.snake;

import at.fhhgb.mc.snake.game.event.state.ChangeEvent;

public class OnSnakePointsChangeEvent extends ChangeEvent {
    public OnSnakePointsChangeEvent(int total, int change) {
        super(total, change);
    }

    @Override
    public StateEventType getType() {
        return StateEventType.SNAKE_POINTS_CHANGE;
    }
}

=== ./ue-09/src/main/java/at/fhhgb/mc/snake/game/event/state/snake/OnSnakeSizeChangeEvent.java ===
package at.fhhgb.mc.snake.game.event.state.snake;

import at.fhhgb.mc.snake.game.event.state.ChangeEvent;

public class OnSnakeSizeChangeEvent extends ChangeEvent {
    public OnSnakeSizeChangeEvent(int total, int change) {
        super(total, change);
    }

    @Override
    public StateEventType getType() {
        return StateEventType.SNAKE_SIZE_CHANGE;
    }
}

=== ./ue-09/src/main/java/at/fhhgb/mc/snake/game/event/state/StateEvent.java ===
package at.fhhgb.mc.snake.game.event.state;

public abstract class StateEvent {
    public enum StateEventType {
        GAME_START,
        GAME_OVER,
        GAME_PAUSE,
        GAME_RESUME,

        SNAKE_POINTS_CHANGE,
        SNAKE_SIZE_CHANGE
    }

    public abstract StateEventType getType();
}

=== ./ue-09/src/main/java/at/fhhgb/mc/snake/game/event/state/ChangeEvent.java ===
package at.fhhgb.mc.snake.game.event.state;

public abstract class ChangeEvent extends StateEvent {
    private final int total;
    private final int change;

    public ChangeEvent(int total, int change) {
        this.total = total;
        this.change = change;
    }

    public int getTotal() {
        return total;
    }

    public int getChange() {
        return change;
    }
}

=== ./ue-09/src/main/java/at/fhhgb/mc/snake/game/struct/Point2D.java ===
package at.fhhgb.mc.snake.game.struct;

import at.fhhgb.mc.snake.game.Snake;
import at.fhhgb.mc.snake.game.options.GameOptions;

import java.util.Objects;

public class Point2D implements Cloneable, Comparable<Point2D> {
    private int x;
    private int y;

    private int maxX;
    private int maxY;

    public Point2D() {
        this(0, 0);
    }

    public Point2D(int x, int y) {
        this(x, y, -1, -1);
    }

    public Point2D(int x, int y, int maxX, int maxY) {
        this.x = x;
        this.y = y;
        this.maxX = maxX;
        this.maxY = maxY;
    }

    public static Point2D fromInt(int value, GameOptions options) {
        if(options == null) {
            throw new IllegalArgumentException("GameOptions cannot be null.");
        }

        return fromInt(value, options.getGameWidth(), options.getGameHeight());
    }

    public static Point2D fromInt(int value, int maxX, int maxY) {
        if(maxX <= 0 || maxY <= 0) {
            throw new IllegalArgumentException("maxX and maxY must be greater than 0.");
        }

        int x = value % maxX;
        int y = value / maxX;

        return new Point2D(x, y, maxX, maxY);
    }

    public int getX() {
        return x;
    }

    public Point2D setX(int x) {

        this.x = Math.max(x, 0);

        if(this.maxX > 0 && this.x > this.maxX) {
            this.maxX = x;
        }

        return this;
    }

    public int getY() {
        return y;
    }

    public Point2D setY(int y) {
        this.y = Math.max(y, 0);

        if(this.maxY > 0 && this.y > this.maxY) {
            this.maxY = y;
        }

        return this;
    }

    public int getMaxX() {
        return maxX;
    }

    public Point2D setMaxX(int maxX) {
        this.maxX = maxX;
        return this;
    }

    public int getMaxY() {
        return maxY;
    }

    public Point2D setMaxY(int maxY) {
        this.maxY = maxY;
        return this;
    }

    public void move(Snake.Direction direction) {
        switch (direction) {
            case UP:    this.y -= 1; break;
            case DOWN:  this.y += 1; break;
            case LEFT:  this.x -= 1; break;
            case RIGHT: this.x += 1; break;
        }

        if(this.maxY > 0) {
            this.y += this.maxY;
            this.y %= this.maxY;
        }

        if(this.maxX > 0) {
            this.x += this.maxX;
            this.x %= this.maxX;
        }
    }

    public int asInt() {
        if(this.maxX <= 0 || this.maxY <= 0) {
            throw new IllegalStateException("Cannot convert to int without maxX and maxY set.");
        }

        return this.x + this.y * this.maxX;
    }

    @Override
    public Point2D clone() {
        try {
            return (Point2D) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new AssertionError();
        }
    }

    public String toString() {
        return String.format("Point2D(%d, %d, %d, %d)", this.x, this.y, this.maxX, this.maxY);
    }

    @Override
    public int compareTo(Point2D other) {
        return Integer.compare(this.asInt(), other.asInt());
    }

    @Override
    public boolean equals(Object o) {
        if(!(o instanceof Point2D point)) {
            return false;
        }

        return this.x == point.x && this.y == point.y &&
            this.maxX == point.maxX && this.maxY == point.maxY;
    }

    @Override
    public int hashCode() {
        return Objects.hash(this.x, this.y, this.maxX, this.maxY);
    }
}

=== ./ue-09/src/main/java/at/fhhgb/mc/snake/controller/MainWindowController.java ===
package at.fhhgb.mc.snake.controller;

import at.fhhgb.mc.snake.elements.dialog.DialogResult;
import at.fhhgb.mc.snake.elements.dialog.FoodConfigDialog;
import at.fhhgb.mc.snake.elements.dialog.GameSpeedDialog;
import at.fhhgb.mc.snake.elements.dialog.GameStartDialog;
import at.fhhgb.mc.snake.game.SnakeGame;
import at.fhhgb.mc.snake.game.options.FoodConfig;
import at.fhhgb.mc.snake.game.options.GameOptions;
import at.fhhgb.mc.snake.game.options.GameFieldConfig;
import at.fhhgb.mc.snake.log.GLog;
import javafx.beans.binding.Bindings;
import javafx.beans.binding.BooleanBinding;
import javafx.beans.property.*;
import javafx.fxml.FXML;
import javafx.scene.control.Label;
import javafx.scene.control.MenuItem;
import javafx.scene.layout.Pane;
import javafx.scene.layout.VBox;

import java.util.Arrays;

public class MainWindowController {
    private enum GameState {
        INIT,
        GAME_OVER,
        PAUSED,
        RUNNING
    }

    @FXML private MenuItem startButton;
    @FXML private MenuItem gameSpeedButton;
    @FXML private MenuItem foodConfigButton;

    @FXML private MenuItem easyPresetButton;
    @FXML private MenuItem mediumPresetButton;
    @FXML private MenuItem hardPresetButton;
    @FXML private MenuItem defaultPresetButton;

    @FXML private VBox gameOverOverlay;
    @FXML private VBox gamePauseOverlay;

    @FXML private Label gameOverPoints;
    @FXML private Label gameOverSize;

    @FXML private Label snakeSize;
    @FXML private Label gamePoints;

    @FXML private Pane gameContainer;

    private final ObjectProperty<GameState> gameStateProperty = new SimpleObjectProperty<>(GameState.INIT);

    private final IntegerProperty score = new SimpleIntegerProperty(0);
    private final IntegerProperty size = new SimpleIntegerProperty(0);

    private SnakeGame activeGame;
    private GameOptions gameOptions;

    @FXML
    public void initialize() {
        BooleanBinding buttonEnabled = this.getGameStateBinding(GameState.INIT, GameState.GAME_OVER);
        this.startButton.disableProperty().bind(buttonEnabled.not());
        this.gameSpeedButton.disableProperty().bind(buttonEnabled.not());
        this.foodConfigButton.disableProperty().bind(buttonEnabled.not());

        this.easyPresetButton.disableProperty().bind(buttonEnabled.not());
        this.mediumPresetButton.disableProperty().bind(buttonEnabled.not());
        this.hardPresetButton.disableProperty().bind(buttonEnabled.not());
        this.defaultPresetButton.disableProperty().bind(buttonEnabled.not());

        this.gameOverOverlay.visibleProperty().bind(this.getGameStateBinding(GameState.GAME_OVER));
        this.gamePauseOverlay.visibleProperty().bind(this.getGameStateBinding(GameState.PAUSED) );

        this.gameOverPoints.textProperty().bind(this.score.asString());
        this.gameOverSize.textProperty().bind(this.size.asString());

        this.gamePoints.textProperty().bind(this.score.asString());
        this.snakeSize.textProperty().bind(this.size.asString());

        this.activeGame = null;
        this.gameOptions = GameOptions.getDefaultCustomOptions();
    }

    @FXML
    private void onStartButtonClick() {
        GameStartDialog gameStartDialog = new GameStartDialog(
            this.gameContainer.getScene().getWindow(),
            this.gameOptions
        );
        DialogResult<GameFieldConfig> startResult = gameStartDialog.showDialog();

        if(startResult.action() != DialogResult.DialogAction.OK) {
            return;
        }

        GLog.info("Starting game!");
        this.gameOptions.setGameSizeConfig(startResult.result());
        this.startNewGame();
    }

    @FXML
    private void onExitButtonClick() {
        System.exit(0);
    }

    @FXML
    private void onGameSpeedButtonClick() {
        GameSpeedDialog dialog = new GameSpeedDialog(
            this.gameContainer.getScene().getWindow(),
            this.gameOptions
        );
        DialogResult<Integer> speedResult = dialog.showDialog();

        if(speedResult.action() != DialogResult.DialogAction.OK) {
            return;
        }

        GLog.info("Speed Value updated: " + speedResult.result());
        this.gameOptions.setTickSpeed(speedResult.result());
    }

    @FXML
    private void onFoodConfigButtonClick() {
        FoodConfigDialog dialog = new FoodConfigDialog(
            this.gameContainer.getScene().getWindow(),
            this.gameOptions
        );
        DialogResult<FoodConfig> foodResult = dialog.showDialog();
        if(foodResult.action() != DialogResult.DialogAction.OK) {
            return;
        }

        GLog.info("Food Config updated: " + foodResult.result());
        this.gameOptions.setFoodConfig(foodResult.result());
    }

    @FXML
    private void onEasyPresetButtonClick() {
        this.gameOptions = GameOptions.getEasyMode();
        this.startNewGame();
    }

    @FXML
    private void onMediumPresetButtonClick() {
        this.gameOptions = GameOptions.getMediumMode();
        this.startNewGame();
    }

    @FXML
    private void onHardPresetButtonClick() {
        this.gameOptions = GameOptions.getHardMode();
        this.startNewGame();
    }

    @FXML
    private void onResetToDefaultPreset() {
        this.gameOptions = GameOptions.getDefaultCustomOptions();
        this.startNewGame();
    }

    @FXML
    private void startNewGame() {
        if(this.activeGame != null) {
            this.activeGame.cleanup();
        }

        this.activeGame = new SnakeGame(this.gameContainer, this.gameOptions)
            .setOnPointsUpdate(event -> this.score.set(event.getTotal()))
            .setOnSnakeGrowth(event -> this.size.set(event.getTotal()))
            .setOnPause(_ -> this.gameStateProperty.set(GameState.PAUSED))
            .setOnResume(_ -> this.gameStateProperty.set(GameState.RUNNING))
            .setOnGameStart(_ -> this.gameStateProperty.set(GameState.RUNNING))
            .setOnGameOver(_ -> this.gameStateProperty.set(GameState.GAME_OVER));

        this.activeGame.start();
    }

    private BooleanBinding getGameStateBinding(GameState... gameStates) {
        return Bindings.createBooleanBinding(
            () -> Arrays.stream(gameStates).anyMatch(state ->
                state == this.gameStateProperty.get()
            ),
            this.gameStateProperty
        );
    }
}
=== ./ue-09/src/main/java/at/fhhgb/mc/snake/controller/dialog/GameSpeedDialogController.java ===
package at.fhhgb.mc.snake.controller.dialog;

import at.fhhgb.mc.snake.elements.dialog.DialogResult;
import at.fhhgb.mc.snake.game.options.GameOptions;
import javafx.beans.property.IntegerProperty;
import javafx.beans.property.SimpleIntegerProperty;
import javafx.fxml.FXML;
import javafx.scene.control.ButtonBar;
import javafx.scene.control.ButtonType;
import javafx.scene.control.Label;
import javafx.scene.control.Slider;

public class GameSpeedDialogController extends DialogBaseController<Integer> {
    @FXML private Label speedSliderLabel;
    @FXML private Slider speedSlider;

    private final static int SLIDER_TO_SPEED_FACTOR = 10;

    private final IntegerProperty sliderValue = new SimpleIntegerProperty(0);
    private final IntegerProperty speedValue = new SimpleIntegerProperty(0);

    @FXML
    public void initialize() {
        this.sliderValue.set((int) this.speedSlider.getMin());
        this.speedValue.bind(this.sliderValue.multiply(SLIDER_TO_SPEED_FACTOR));

        this.speedSlider.valueProperty().bindBidirectional(this.sliderValue);
        this.speedSliderLabel.textProperty().bind(
            this.speedValue.asString("Game Speed: %dms")
        );
    }

    @Override
    public void initializeWithOptions(GameOptions options) {
        this.sliderValue.set(options.getTickSpeed() / SLIDER_TO_SPEED_FACTOR);
    }

    @Override
    public DialogResult<Integer> getResult(ButtonType buttonType) {
        if(buttonType.getButtonData() != ButtonBar.ButtonData.OK_DONE) {
            return DialogResult.invalid();
        }

        return new DialogResult<>(
            DialogResult.DialogAction.OK,
            speedValue.get()
        );
    }
}

=== ./ue-09/src/main/java/at/fhhgb/mc/snake/controller/dialog/FoodConfigDialogController.java ===
package at.fhhgb.mc.snake.controller.dialog;

import at.fhhgb.mc.snake.controller.models.FoodConfigModel;
import at.fhhgb.mc.snake.elements.NumericTextFieldTableCell;
import at.fhhgb.mc.snake.elements.dialog.DialogResult;
import at.fhhgb.mc.snake.game.options.FoodConfig;
import at.fhhgb.mc.snake.game.options.GameOptions;
import javafx.beans.binding.BooleanBinding;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.scene.control.*;
import javafx.scene.paint.Color;

import java.util.stream.Collectors;

public class FoodConfigDialogController extends DialogBaseController<FoodConfig> {
    @FXML private TableView<FoodConfigModel> foodTable;

    @FXML private TableColumn<FoodConfigModel, Integer> pointsIncreaseColumn;
    @FXML private TableColumn<FoodConfigModel, Integer> lengthIncreaseColumn;
    @FXML private TableColumn<FoodConfigModel, Integer> spawnNewFoodAmountColumn;
    @FXML private TableColumn<FoodConfigModel, Color> colorColumn;

    @FXML private Button removeFoodButton;

    private final ObservableList<FoodConfigModel> foodList = FXCollections.observableArrayList();

    @FXML
    public void initialize() {
        this.foodTable.setItems(this.foodList);

        this.foodTable.setEditable(true);
        this.setupIntColumn(this.pointsIncreaseColumn, FoodConfigModel.INT_COLUMN.POINTS_INCREASE);
        this.setupIntColumn(this.lengthIncreaseColumn, FoodConfigModel.INT_COLUMN.LENGTH_INCREASE);
        this.setupIntColumn(this.spawnNewFoodAmountColumn, FoodConfigModel.INT_COLUMN.SPAWN_NEW_AMOUNT);

        this.setupColorColumn(this.colorColumn);

        this.removeFoodButton.disableProperty().bind(
            foodTable.getSelectionModel().selectedItemProperty().isNull()
        );
    }

    @Override
    public void initializeWithOptions(GameOptions options) {
        this.foodList.addAll(
            options.getAvailableFoods()
                .stream()
                .map(FoodConfigModel::new)
                .collect(Collectors.toCollection(FXCollections::observableArrayList))
        );
    }

    @FXML
    private void onAddFoodClick() {
        this.foodList.add(FoodConfigModel.getDefault());
    }

    @FXML
    private void onRemoveFoodClick() {
        FoodConfigModel selected = this.foodTable.getSelectionModel().getSelectedItem();
        if (selected != null) {
            this.foodList.remove(selected);
        }
    }

    @Override
    public BooleanBinding getInputsValidBinding() {
        return new BooleanBinding() {
            {
                super.bind(foodList);
            }

            @Override
            protected boolean computeValue() {
                return !foodList.isEmpty();
            }
        };
    }

    @Override
    public DialogResult<FoodConfig> getResult(ButtonType buttonType) {
        if(buttonType.getButtonData() != ButtonBar.ButtonData.OK_DONE) {
            return DialogResult.invalid();
        }

        return new DialogResult<>(
            DialogResult.DialogAction.OK,
            new FoodConfig(
                1,
                this.foodList.stream()
                    .map(FoodConfigModel::toFoodValueConfig)
                    .toList()
            )
        );
    }

    private void setupIntColumn(TableColumn<FoodConfigModel, Integer> column, FoodConfigModel.INT_COLUMN type) {
        column.setCellValueFactory(
            cellData ->
                cellData.getValue().getProperty(type).asObject()
        );

        column.setCellFactory(
            _ -> new NumericTextFieldTableCell<>()
        );

        column.setOnEditCommit(evt -> {
            Integer newValue = evt.getNewValue();
            FoodConfigModel model = evt.getRowValue();
            model.update(type, newValue);
        });
    }

    private void setupColorColumn(TableColumn<FoodConfigModel, Color> column) {
        column.setCellValueFactory(cellData -> cellData.getValue().colorProperty());

        column.setCellFactory(_ -> new TableCell<>() {
            private final ColorPicker colorPicker = new ColorPicker();
            {
                colorPicker.setOnAction(_ -> {
                    FoodConfigModel model = getTableView().getItems().get(getIndex());
                    model.colorProperty().set(colorPicker.getValue());
                });
            }

            @Override
            protected void updateItem(Color color, boolean empty) {
                super.updateItem(color, empty);

                if (empty || color == null) {
                    setGraphic(null);
                } else {
                    colorPicker.setValue(color);
                    setGraphic(colorPicker);
                }
            }
        });
    }
}

=== ./ue-09/src/main/java/at/fhhgb/mc/snake/controller/dialog/GameStartDialogController.java ===
package at.fhhgb.mc.snake.controller.dialog;

import at.fhhgb.mc.snake.elements.dialog.DialogResult;
import at.fhhgb.mc.snake.game.options.GameOptions;
import at.fhhgb.mc.snake.game.options.GameFieldConfig;
import at.fhhgb.mc.snake.game.struct.Point2D;
import at.fhhgb.mc.snake.log.GLog;
import javafx.beans.binding.BooleanBinding;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.IntegerProperty;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.beans.property.SimpleIntegerProperty;
import javafx.fxml.FXML;
import javafx.scene.control.ButtonBar;
import javafx.scene.control.ButtonType;
import javafx.scene.control.CheckBox;
import javafx.scene.control.TextField;

public class GameStartDialogController extends DialogBaseController<GameFieldConfig> {
    @FXML private TextField rowInput;
    @FXML private TextField columnInput;

    @FXML private TextField initialRow;
    @FXML private TextField initialColumn;

    @FXML private CheckBox enableWalls;

    private final IntegerProperty rowInputValue = new SimpleIntegerProperty(10);
    private final IntegerProperty columnInputValue = new SimpleIntegerProperty(10);
    private final IntegerProperty initialRowInputValue = new SimpleIntegerProperty(1);
    private final IntegerProperty initialColumnInputValue = new SimpleIntegerProperty(1);
    private final BooleanProperty enableWallsValue = new SimpleBooleanProperty(false);


    @FXML
    public void initialize() {
        DialogBaseController.BindTextFieldToIntegerProperty(this.rowInput, this.rowInputValue);
        DialogBaseController.BindTextFieldToIntegerProperty(this.columnInput, this.columnInputValue);
        DialogBaseController.BindTextFieldToIntegerProperty(this.initialRow, this.initialRowInputValue);
        DialogBaseController.BindTextFieldToIntegerProperty(this.initialColumn, this.initialColumnInputValue);
        this.enableWalls.selectedProperty().bindBidirectional(this.enableWallsValue);
    }

    @Override
    public void initializeWithOptions(GameOptions options) {
        this.rowInput.setText(String.valueOf(options.getGameHeightWithoutOffset()));
        this.columnInput.setText(String.valueOf(options.getGameWidthWithoutOffset()));

        Point2D initialPosition = options.getStartingPosition();
        this.initialRow.setText(String.valueOf(initialPosition.getY()));
        this.initialColumn.setText(String.valueOf(initialPosition.getX()));
        this.enableWalls.setSelected(options.isWallEnabled());
    }

    @Override
    public BooleanBinding getInputsValidBinding() {
        return new BooleanBinding() {
            {
                super.bind(
                    rowInputValue,
                    columnInputValue,
                    initialRowInputValue,
                    initialColumnInputValue
                );
            }

            @Override
            protected boolean computeValue() {
                return rowInputValue.get() >= 10 && rowInputValue.get() <= 100 &&
                    columnInputValue.get() >= 10 && columnInputValue.get() <= 100 &&

                    initialRowInputValue.get() >= 0 &&
                    initialRowInputValue.get() < rowInputValue.get() &&

                    initialColumnInputValue.get() >= 0 &&
                    initialColumnInputValue.get() < columnInputValue.get();
            }
        };
    }

    @Override
    public DialogResult<GameFieldConfig> getResult(ButtonType buttonType) {
        GLog.info("Row Val: " + this.rowInputValue.get());

        if(buttonType.getButtonData() != ButtonBar.ButtonData.OK_DONE) {
            return DialogResult.invalid();
        }

        return new DialogResult<>(
            DialogResult.DialogAction.OK,
            new GameFieldConfig(
                this.columnInputValue.get(),
                this.rowInputValue.get(),
                new Point2D(
                    this.initialColumnInputValue.get(),
                    this.initialRowInputValue.get()
                ),
                this.enableWallsValue.get()
            )
        );
    }
}

=== ./ue-09/src/main/java/at/fhhgb/mc/snake/controller/dialog/DialogBaseController.java ===
package at.fhhgb.mc.snake.controller.dialog;

import at.fhhgb.mc.snake.elements.dialog.DialogResult;
import at.fhhgb.mc.snake.game.options.GameOptions;
import at.fhhgb.mc.snake.log.GLog;
import javafx.beans.binding.BooleanBinding;
import javafx.beans.property.IntegerProperty;
import javafx.scene.control.ButtonType;
import javafx.scene.control.TextField;
import javafx.scene.control.TextFormatter;
import javafx.util.converter.IntegerStringConverter;

import java.util.function.UnaryOperator;

public abstract class DialogBaseController<T> {
    public abstract DialogResult<T> getResult(ButtonType buttonType);
    public abstract void initializeWithOptions(GameOptions options);

    public BooleanBinding getInputsValidBinding() {
        return new BooleanBinding() {
            @Override
            protected boolean computeValue() {
                return true;
            }
        };
    }

    protected static void BindTextFieldToIntegerProperty(TextField textField, IntegerProperty valueProperty) {
        UnaryOperator<TextFormatter.Change> filter = change -> {
            String newText = change.getControlNewText();
            if (newText.matches("-?\\d*")) {
                return change;
            }
            return null;
        };

        IntegerStringConverter converter = new IntegerStringConverter();
        TextFormatter<Integer> textFormatter = new TextFormatter<>(converter, 0, filter);
        textField.setTextFormatter(textFormatter);

        textField.textProperty().addListener((obs, oldValue, newValue) -> {
            GLog.info("Text changed to " + newValue);
            try {
                int parsedValue = Integer.parseInt(newValue);
                valueProperty.set(parsedValue);
                GLog.info("IntegerProperty updated to " + valueProperty.get());
            } catch (NumberFormatException e) {
                GLog.error("Invalid integer input: " + newValue);
                valueProperty.set(-1);
            }
        });
    }
}

=== ./ue-09/src/main/java/at/fhhgb/mc/snake/controller/models/FoodConfigModel.java ===
package at.fhhgb.mc.snake.controller.models;

import at.fhhgb.mc.snake.game.options.FoodConfig;
import javafx.beans.property.IntegerProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleIntegerProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.scene.paint.Color;

public class FoodConfigModel {
    public enum INT_COLUMN {
        POINTS_INCREASE(100,0),
        LENGTH_INCREASE(1,1),
        SPAWN_NEW_AMOUNT(1,1);

        private final int defaultValue;
        private final int minValue;

        INT_COLUMN(int defaultValue, int minValue) {
            this.defaultValue = defaultValue;
            this.minValue = minValue;
        }

        public int validate(Integer value) {
            return value == null || value < this.minValue ?
                       this.defaultValue :
                       value;
        }
    }

    private final IntegerProperty pointsIncrease;
    private final IntegerProperty lengthIncrease;
    private final IntegerProperty spawnNewAmount;
    private final ObjectProperty<Color> color;

    public FoodConfigModel(FoodConfig.FoodValueConfig foodConfig) {
        this.pointsIncrease = new SimpleIntegerProperty(foodConfig.pointIncrease());
        this.lengthIncrease = new SimpleIntegerProperty(foodConfig.lengthIncrease());
        this.spawnNewAmount = new SimpleIntegerProperty(foodConfig.spawnNewAmount());
        this.color = new SimpleObjectProperty<>(foodConfig.color());
    }

    public static FoodConfigModel getDefault() {
        return new FoodConfigModel(
            new FoodConfig.FoodValueConfig(
                INT_COLUMN.POINTS_INCREASE.defaultValue,
                INT_COLUMN.LENGTH_INCREASE.defaultValue,
                INT_COLUMN.SPAWN_NEW_AMOUNT.defaultValue,
                Color.RED
            )
        );
    }

    public IntegerProperty pointsIncreaseProperty() {
        return this.pointsIncrease;
    }

    public IntegerProperty lengthIncreaseProperty() {
        return this.lengthIncrease;
    }

    public IntegerProperty spawnNewAmountProperty() {
        return this.spawnNewAmount;
    }

    public ObjectProperty<Color> colorProperty() {
        return this.color;
    }

    public IntegerProperty getProperty(INT_COLUMN type) {
        return switch (type) {
            case POINTS_INCREASE -> this.pointsIncrease;
            case LENGTH_INCREASE -> this.lengthIncrease;
            case SPAWN_NEW_AMOUNT -> this.spawnNewAmount;
        };
    }

    public void update(INT_COLUMN type, Integer value) {
        value = type.validate(value);

        switch (type) {
            case POINTS_INCREASE -> this.pointsIncreaseProperty().set(value);
            case LENGTH_INCREASE -> this.lengthIncreaseProperty().set(value);
            case SPAWN_NEW_AMOUNT -> this.spawnNewAmountProperty().set(value);
        }
    }

    public FoodConfig.FoodValueConfig toFoodValueConfig() {
        return new FoodConfig.FoodValueConfig(
            this.pointsIncrease.get(),
            this.lengthIncrease.get(),
            this.spawnNewAmount.get(),
            this.color.get()
        );
    }
}

=== ./ue-09/src/main/java/at/fhhgb/mc/snake/Main.java ===
package at.fhhgb.mc.snake;

import at.fhhgb.mc.snake.log.GLog;
import atlantafx.base.theme.PrimerDark;
import javafx.application.Application;
import javafx.fxml.FXMLLoader;
import javafx.scene.Scene;
import javafx.stage.Stage;

import java.io.IOException;

public class Main extends Application {
    @Override
    public void start(Stage stage) throws IOException {
        GLog.enableLogging();
        Application.setUserAgentStylesheet(new PrimerDark().getUserAgentStylesheet());

        FXMLLoader fxmlLoader = new FXMLLoader(Main.class.getResource("main-window.fxml"));
        Scene scene = new Scene(fxmlLoader.load(), 320, 240);
        stage.setTitle("Snake but different");
        stage.setScene(scene);

        stage.setWidth(900);
        stage.setHeight(900);

        stage.show();
    }

    public static void main(String[] args) {
        launch();
    }
}
=== ./ue-09/src/main/java/at/fhhgb/mc/snake/elements/NumericTextFieldTableCell.java ===
package at.fhhgb.mc.snake.elements;

import atlantafx.base.util.IntegerStringConverter;
import javafx.geometry.Pos;
import javafx.scene.control.TextField;
import javafx.scene.control.TextFormatter;
import javafx.scene.control.cell.TextFieldTableCell;

import java.util.function.UnaryOperator;

public class NumericTextFieldTableCell<T> extends TextFieldTableCell<T, Integer> {
    public NumericTextFieldTableCell() {
        super(new IntegerStringConverter());

        TextField textField = (TextField) this.getGraphic();

        if(textField == null) {
            return;
        }

        UnaryOperator<TextFormatter.Change> filter = change -> {
            String newText = change.getControlNewText();
            if (newText.matches("-?\\d*")) {
                return change;
            }

            return null;
        };

        textField.setTextFormatter(
            new TextFormatter<>(new IntegerStringConverter(), 0, filter)
        );
    }

    @Override
    public void updateItem(Integer item, boolean empty) {
        super.updateItem(item, empty);
        if (!empty && this.getGraphic() != null) {
            ((TextField) this.getGraphic()).setAlignment(Pos.CENTER_RIGHT);
        }
    }
}

=== ./ue-09/src/main/java/at/fhhgb/mc/snake/elements/dialog/DialogBase.java ===
package at.fhhgb.mc.snake.elements.dialog;

import at.fhhgb.mc.snake.Main;
import at.fhhgb.mc.snake.controller.dialog.DialogBaseController;
import at.fhhgb.mc.snake.game.options.GameOptions;
import at.fhhgb.mc.snake.log.GLog;
import javafx.fxml.FXMLLoader;
import javafx.scene.control.Button;
import javafx.scene.control.ButtonType;
import javafx.scene.control.Dialog;
import javafx.scene.layout.Pane;
import javafx.stage.Modality;
import javafx.stage.Window;

import java.io.IOException;

public abstract class DialogBase<T> extends Dialog<DialogResult<T>> {

    protected DialogBase(Window owner, String fxmlName, GameOptions options) {
        try {
            FXMLLoader loader = new FXMLLoader(Main.class.getResource(fxmlName));
            Pane root = loader.load();
            DialogBaseController<T> controller = loader.getController();
            controller.initializeWithOptions(options);

            this.initOwner(owner);
            this.initModality(Modality.APPLICATION_MODAL);
            this.getDialogPane().setContent(root);
            this.setResultConverter(controller::getResult);

            this.setButtons(ButtonType.OK, ButtonType.CANCEL);

            Button okButton = (Button) this.getDialogPane().lookupButton(ButtonType.OK);
            okButton.disableProperty().bind(controller.getInputsValidBinding().not());
        } catch(IOException ex) {
            GLog.error(ex.getMessage());
        }
    }

    protected void setButtons(ButtonType... buttonTypes) {
        this.getDialogPane().getButtonTypes().clear();
        this.getDialogPane().getButtonTypes().setAll(buttonTypes);
    }

    public DialogResult<T> showDialog() {
        return this.showAndWait().orElse(DialogResult.invalid());
    }
}

=== ./ue-09/src/main/java/at/fhhgb/mc/snake/elements/dialog/FoodConfigDialog.java ===
package at.fhhgb.mc.snake.elements.dialog;

import at.fhhgb.mc.snake.game.options.FoodConfig;
import at.fhhgb.mc.snake.game.options.GameOptions;
import javafx.stage.Window;

public class FoodConfigDialog extends DialogBase<FoodConfig> {
    private final static String fxmlPath = "dialog/food-config-dialog.fxml";

    public FoodConfigDialog(Window owner, GameOptions options) {
        super(owner, fxmlPath, options);

        this.getDialogPane().setPrefWidth(700);
    }
}

=== ./ue-09/src/main/java/at/fhhgb/mc/snake/elements/dialog/GameSpeedDialog.java ===
package at.fhhgb.mc.snake.elements.dialog;

import at.fhhgb.mc.snake.game.options.GameOptions;
import javafx.scene.control.ButtonBar;
import javafx.scene.control.ButtonType;
import javafx.stage.Window;

public class GameSpeedDialog extends DialogBase<Integer> {
    private final static String fxmlPath = "dialog/game-speed-dialog.fxml";

    public GameSpeedDialog(Window owner, GameOptions options) {
        super(owner, fxmlPath, options);

        this.setButtons(
            new ButtonType("Done", ButtonBar.ButtonData.OK_DONE),
            ButtonType.CANCEL
        );
    }
}

=== ./ue-09/src/main/java/at/fhhgb/mc/snake/elements/dialog/GameStartDialog.java ===
package at.fhhgb.mc.snake.elements.dialog;

import at.fhhgb.mc.snake.game.options.GameOptions;
import at.fhhgb.mc.snake.game.options.GameFieldConfig;
import javafx.stage.Window;

public class GameStartDialog extends DialogBase<GameFieldConfig> {
    private final static String fxmlPath = "dialog/game-start-dialog.fxml";

    public GameStartDialog(Window owner, GameOptions options) {
        super(owner, fxmlPath, options);
    }
}

=== ./ue-09/src/main/java/at/fhhgb/mc/snake/elements/dialog/DialogResult.java ===
package at.fhhgb.mc.snake.elements.dialog;

public record DialogResult<T>(DialogAction action, T result) {
    public enum DialogAction {
        OK, CANCEL
    }

    public static <T> DialogResult<T> invalid() {
        return new DialogResult<>(DialogAction.CANCEL, null);
    }
}

=== ./ue-09/src/main/java/at/fhhgb/mc/snake/log/GLog.java ===
package at.fhhgb.mc.snake.log;

import java.util.logging.Level;


public class GLog {
    private static boolean enableLogging = false;

    public static void enableLogging() {
        GLog.enableLogging = true;
    }

    public static void disableLogging() {
        GLog.enableLogging = false;
    }

    public static void info(String message, Object... args) {
        GLog.write(Level.INFO, message, args);
    }


    public static void error(String message, Object... args) {
        GLog.write(Level.SEVERE, message, args);
    }

    public static void debug(String message, Object... args) {
        GLog.write(Level.FINE, message, args);
    }

    private static void write(Level level, String message, Object... args) {
        if (GLog.enableLogging) {
            System.out.printf("[%s] " + String.format(message, args) + System.lineSeparator(), level.getName());
        }
    }
}

